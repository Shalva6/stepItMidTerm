გვაქვს ორი კლასი:
წიგნი და წიგნების მენეჯერი.

1. წიგნის კლასი:
ეს კლასი უბრალოდ წიგნის შემქნაში გვეხმარება. მომხმარებელს ეთხოვნება რომ დაამატოს მწერლის სახელი, წიგნის სახელი და
რომელ წელს გამოიშვა ეს წიგნი.

ხდება წიგნის ინფორმაციის 'ვალიდაცია' while True ლუპით. while True გვინდა იმიტომ რომ მომხმარებელი მანამდე დარჩეს
სისტემაში, სანამ თვოთონ არ მოითხოვს გამოსვლას. ვთავაზობთ შესაძლო მოქმედებებს და მათ აიდის. მომხმარებელი
შეიყვანს რიცხვს 1დან 4ის ჩათვლით და გაიშვება შესაბამისი ქმედება.
რადგან int ტიპის ინფორმაცია შეყავს ქმედების არჩევისას მომხმარებელს, ხდება ვალიდაცია რომ მომხმარებელმა არ შეიყვანოს არა-რიცხვული
მონაცემი და სისტემა არ გატეხოს.

2. წიგნების მენეჯერი:
ვიყენებთ ჯეისონის ფაილს სიმარტივისთვის და წაკითხვადობისთვის. თავიდან __init__ში ინფორმაცია ჯეისონიდან მოგვაქვს და
ვაძლევთ ცვლადს რომელიც თვითონ ამ კლასს ეკუთვნის. self.__listOfAllBooksში '__' ნიშნავს რომ ეს ცვლადი ამ კლასის გარეთ
არ გავა. თავიდანვე ვქმნით ამ კლასთან დაკავშირებულ ცვლადს (manager = BookManager()) რომ ჩავატაროთ მოქმედებები. ხშირად ვიყენებთ
ფუნქცია .lower()ს, რომ, მაგალითად, Paulo coelho და PAULO COELHO სხვადასხვა ადამიანად არ აღიქვას პროგრამამ.

პირველი ფუნქცია: showAllBooks(self) ფუნქციას გამოაქვს ყველა წიგნი თავისი ავტორით, რა წიგნი დაწერეს და რომელ წელს დალაგებული
ფორმატით. ხდება self.__listOfAllBooksში იტერაცია for ლუპით (სადაც თითო მწერლის სეგმენტი აღინიშნება eachPerson
დროებითი ცვლადით), და თითოეულ ჯერზე იბეჭდება მწერლის სახელი eachPerson['Author']. შემდეგ, ხდება თითოეულ სეგმენტზე
წიგნების სიასე იტერაცია. ამ წიგნების სიაში წიგნი და თავის გამოშვების წელი აღქმულია როგორც თავისი ცალკეული სეგმენტი მთლიანი
წიგნების სიაში მარტივი წვდომისთვის. ანუ:
[
    {
        "Title": "Eleven Minutes",
        "Year": 2003
    },
    {
        "Title": "The Alchemist",
        "Year": 1988
    }
]
აქ, ინდექსი 0 მოგცემს:
{
    "Title": "Eleven Minutes",
    "Year": 2003
}
ინდექსი 1 კი:
{
        "Title": "The Alchemist",
        "Year": 1988
}

მეორე ფუნქცია: dataSaver(self) ფუნქცია ააფდეითებს ჯეისონის ორიგინალურ ფაილს. ის წვდომას ამყარებს ორიგინალურ
ჯეისონის ფაილთან და დროებით ცვლადში (self.__listOfAllBooks) შეცვლილ ინფორმაციას უშვებს შიგნით. ამას ვიძახებთ ყოველ ჯერზე
როდესაც რაღაცას ვცვლით რომ ინფორმაცია არ დაიკარგოს.

მესამე ფუნქცია: addBook(self, userBook) ფუნქცია უკვე იყენებს წიგნის კლასს სადაც შევქმენით წიგნი თავისი პარამეტრებით (userBook).
ფუნქცია showAllBooks(self) ლოგიკის გამოყენებით ვნახულობთ, არსებობს თუ არა ახალი ცვლადით შექმნილი წიგნის ავტორი
სიაში. თუ კი, ახალ  წიგნს უბრალოდ სიაში ამატებს ამ მწერალთან და ხდება dataSaver(self) ფუნქციით ჯეისონ ფაილის დააფდეითება.
აქ ბოლოს ვუწერთ returnს რომ დაასრულოს ყველა ქმედება და შემდეგი ინსტრუქციები აღარ შეასრულოს. თუ
მწერალი სიაში არ არსებობს, ხდება ჯეისონის ფაილში ახალი წიგნის (თავის ავტორთან) შექმნდა და დამატება.

მეოთხე ფუნქცია: ისევ ფუნქცია showAllBooks(self) ლოგიკის გამოყენებით ვადარებთ, არსებობს თუ არა წიგნი ამ სათაურით. სხვა
პარამეტრები (წელი, ავტორის სახელი) გადაეცემა Noneად რომ პროგრამა არ დავტვირთოთ.

ისევ ბოლო while True ლუპს რომ დავუბრუნდეთ, ბოლოს ხდება match-caseების გამოყენებით მომხმარებლის მიერ შეყვანილის
აიდის დახმარებით შესაფერისი მოქმდების შესრულება. არ ვიყენებთ if-elseს სიმარტივისთვის. case _: აღიქვავს ყველა იმ მნიშვნელობას,
რომელსაც თავისი შესაფერისი ქმედება არ უწერია.